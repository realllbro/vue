

## Vue.js

[toc]

# 6.Vue.js 고급 개발자 되기

## 6-1.뷰 중고급 레벨로 올라가기 위한 지식

* Vuex : 상태 관리 라이브러리
* Vue Reactivity : 뷰가 데이터 변화를 감지하고 자동으로 화면을 갱신하는 특성
* Server Side Rendering : 서버 사이드 렌더링

### 6-1-1.Vuex

* 뷰엑스(Vuex)는 애플리케이션의 상태관리(state management)를 돕는 라이브러리다. 

  먼저 상태(state)란 뷰 data 속성과 비슷하다고 생각하면 된다. 그러면 뷰 data 속성과 '상태'는 실질적으로

  어떤 차이점이 있는지 다음 그림을 살펴보자.

  ![](C:/bro-lab/01.vue/vue/markdown/img/150.png) 

  위 그림은 id 라는 데이터를 로그인 폼 컴포넌트에서 메인 컴포넌트로 전달하는 컴포넌트 간 관계도다.

  로그인 폼 컴포넌트를 비롯한 모든 컴포넌트에서 id 라는 데이터(상태)를 서로 공유하고 있다.

  만약 로그인 폼에서 입력받은 id를 메인 컴포넌트에 표시해야 한다면 로그인 폼 컴포넌트에서 메인 컴포넌트로

  데이터 속성 id를 전달해야 한다. 그러면 id는 상위 컴포넌트인 로그인 컴포넌트와 최상위 컴포넌트를 거쳐 

  다시 최상위의 하위 컴포넌트인 메인 컴포넌트로 전달된다. 이처럼 특정 데이터를 여러 컴포넌트가 공유하고 있을 때 

  그 데이터를 '상태' 라고 한다.

  

  그럼 왜 상태 관리가 필요할까?
  ![](C:/bro-lab/01.vue/vue/markdown/img/151.png) 

  위 그림처럼 로그인 폼 컴포넌트에서 메인 컴포넌트로 데이터를 전달할 때 사이에 너무 많은 컴포넌트가 존재하면

  props 로 데이터를 전달한다고 할 때 모든 컴포넌트에 props를 설정해 줘야 한다. 손도 많이 가고 관리가 힘들어 진다.

  

  이때 props 대신 이벤트 버스를 활영하면 어떻게 될까? 상-하위 간의 데이터 전달 구조를 따르지 않고도 한 번에 로그인

  폼 컴포넌트에서 메인 컴포넌트로 데이터를 보낼 수 있어 쉽게 데이터를 전달할 수 있을 것이다. 다만 여기서 생기는 문제점은

  단방향 데이터 흐름이 아닌 셀 수 없이 많은 데이터 흐름(Countless Ways Data Flow)이 된다. 아래와 같이 말이다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/152.png) 

  이럴 때 필요한게 바로 상태 관리다. 애플리케이션 에서 사용하는 모든 데이터를 중앙에서 관리하여 크기가 큰 애플리케이션의 

  데이터 관리를 효율적으로 하는 것이 상태 관리의 목적이다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/153.png) 

  이처럼 상태 관리는 컴포넌트가 너무 많아 관리가 어려운 복잡한 규모의 애플리케이션에서 필요하다.

  또한 뷰엑스에서 다루는 State, Getters, Mutations, Actions 라는 기능의 사용 방법과 개념은 범위가 넓은 주제다.

  따라서 뷰의 기본적인 개념들을 잡아 가면서 추후에 필요할 때 배우는 것이 좋다.

  

  뷰엑스에 대한 자세한 가이드는 아래 링크를 참고하자.

  공식사이트 : https://vuex.vuejs.org/en/intro.html

  뷰엑스 튜토리얼 : https://joshua1988.github.io/web-development/vuejs/vuex-start/

### 6-1-2.뷰의 반응성

* 뷰의 반응성(Vue Reactivity)은 뷰가 데이터 변화를 감지했을 때 자동으로 화면을 다시 갱신하는 특성이다.

  뷰의 반응성에 대해 알아두면 프레임워크 내부적으로 화면을 그리는 방법, 가상 돔이 동작하는 방법, 화면을 빠르게 

  그리기 위해 브라우저에 부하를 주지 않고 돔을 추가, 삭제 하는 방법을 익힐 수 있다.

  그럼 데이터가 변경되었을 때 어떻게 뷰에서 자동으로 화면을 갱신하는지 간단하게 살펴보자.

  

  먼저, 뷰로 애플리케이션을 구현하려면 인스턴스를 생성해야 한다. 그리고 인스턴스가 생성될 때 data 속성에 정의된

  객체들은 특정 변환 작업을 거친다. 라이브러리에서 data에 정의된 모든 속성(객체)을 getter, setter의 형태로 

  변환하는 것이다. 여기서 getter와 setter라는 속성은 사용자가 접근할 수 있는 속성이 아니다. 다만 뷰 인스턴스에

  정의해 놓은 data 속성에 변화가 생길 때 뷰에서 감지하기 위해 라이브러리 내부적으로 필요한 속성이다.

  

  그리고 화면을 다시 갱신하는 속성인 watcher에 대해서도 알아둘 필요가 있다. watcher 속성은 모든 컴포넌트에 존재하는

  속성으로, 화면을 다시 그리는 데 중용한 역할을 한다. 예를 들어, 인스턴스가 화면에 올라가고 나서 특정 data 속성을 

  바꾸거나 접근하면 watcher 에서 해당 사실을 감지한다. 그리고 watcher에서 다시 화면을 그리라는 신호를 보낸다.

  

  이 외에도 뷰의 반응성에 대해 한 가지 알아둘 점이 있다. 바로 '인스턴스 data 속성에 반응성이 언제 생기는가?' 하는 것이다.

  정답은 '인스턴스를 생성하는 시점' 이다. 따라서 인스턴스를 정의할 때 data 속성에 정의하지 않고 인스턴스를 생성하고 난 후 

  data 속성에 객체를 추가하면 그 객체에는 반응성이 생기지 않는다. 반응성이 없다는 것은 해당 객체의 변화가 있든 없든 뷰에

  서 화면을 다시 갱신하지 않는다는 의미다.

  

  이처럼 뷰가 라이브러리 내부적으로 어떻게 동작하는지를 알면 더 좋은 코드를 작성할 수 있다. 

  뷰의 반응성에 대해 더 자세히 알고 싶다면 다음 링크를 참고하자.

  뷰의 반응성 : https://vuejs.org/v2/guide/reactivity.html

### 6-1-3.서버 사이드 렌더링

* 서버 사이드 렌더링(Server-side Rendering)은 뷰엑스와 마찬가지로 별도의 라이브러리와 공식 사이트가 있을 정도로

  광범위한 주제이기 때문에 여기서는 자세히 다루지 않는다. 다만 서버 사이드 렌더링과 클라이언트 사이드 렌더링(Client-Side 

  Rendering)에 대한 차이는 알고 있어야 필요할 때 찾아서 사용할 수 있기 때문에 간단히 살펴보고 넘어가자.

  > 서버 사이드 렌더링은 뷰에서 Nuxt.js 라는 라이브러리로 지원하고 있다.

  * ##### 클라이언트 사이드 렌더링과 서버 사이드 렌더링의 차이

    클라이언트 사이드 렌더링이란 웹 페이지를 화면에 그릴 때 화면을 그리는 동작을 클라이언트(브라우저)에서 수행하는 것을

    의미한다. 

    ![](C:/bro-lab/01.vue/vue/markdown/img/154.png) 

    일단 클라이언트 사이드 렌러링이든 서버 사이드 렌더링이든 브라우저는 웹 페이지를 화면에 나타내는 역할을 한다.

    다만 완벽하게 그려진 HTML 페이지를 나타내는 것과 일부만 그려져 있어 추가로 더 그려야 할 것이 남아 있는 

    HTML 페이지를 나타내는 것은 차이가 있다.

    

    클라이언트 사이드 렌더링은 다 그려져 있지 않은 HTML 페이지를 브라우저에서 받고 프런트엔드 프레임워크와 같은 자바

    스크립트를 이용하여 나머지 부분을 그리는 것을 의미한다. 서버 사이드 렌더링은 완벽히 그려진 HTML 페이지를 브라우저에서

    받는 것을 의미한다. 리액트, 앵귤러를 비롯하여 뷰 프레임워크의 기본 사용 방법은 클라이언트 사이드 렌더링이며, 아래의 

    화면을 보면 쉽게 이해할 수 있다.

    ![](C:/bro-lab/01.vue/vue/markdown/img/155.png) 

    위 파일은 간단한 HTML 페이지다. 이 페이지의 코드를 클라이언트 사이드 렌더링과 서버 사이드 렌더링 관점에서 비교해 보겠다.

    먼저 클라이언트 사이드 렌더링 코드를 살펴보자.

    [뷰를 이용한 클라이언트 사이드 렌더링 코드]

    ```html
    <html>
      <head>
        <title>Vue Client Side Rendering</title>
      </head>
      <body>
        <div id="app">
          {{ message }}
          <list-component></list-component>
        </div>
    
        <script src="https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"></script>
        <script>
          var cmp = {
            template: '<ul><li>item1</li><li>item2</li></ul>'
          };
    
          new Vue({
            el: '#app',
            data:{
              message:'Hello Vue.js!'  
            },
            components: {
              'list-component': cmp
            }
          });
        </script>
      </body>
    </html>
    ```

    이 코드가 화면에 표시되는 과장을 살펴보자. 먼저 서버에서 보내준 HTML 파일을 받았을 때 브라우저가 이 HTML 파일을 

    화면에 로딩하면서 뷰 프레임워크(자바스크립트)를 이용하여 인스턴스를 생성한다. 그리고 &lt;ul>과 &lt;li> 태그를 템플릿 속성에

    생성하여 화면에 붙여 넣는다. 이제 화면이 완성되어 브라우저에 최종 형태가 표시된다.

    

    그러면 위 코드를 서버 사이드 렌더링 코드로 바꿔 보면 어떨까?

    [서버 사이드 렌더링 코드]

    ```html
      <body>
        <div id="app">
    	  Hello Vue.js!
        	<ul>
              <li>item1</li>
              <li>item2</li>          
            </ul>
        </div>
      </body>
    ```

    서버 사이드 렌더링에서는 서버에서 브라우저로 HTML 파일을 넘겨줄 때 화면에 나타낼 텍스트 값과 &lt;ul>, &lt;li> 태그가 이미 

    완벽하게 그려져 있다. 따라서 브라우저에서는 그냥 해당 파일을 표시하기만 하면 되고, 별도의 자바스크립트를 이용한 화면 

    렌더링은 필요하지 않는다.

    

    결과적으로, 클라이언트 사이드 렌더링과 서버 사이드 렌더링의 차이를 아래와 같은 그림으로 나타낼 수 있다.

    ![](C:/bro-lab/01.vue/vue/markdown/img/156.png) 

    그럼 어떤 상황에서 클라이언트 사이드 렌더링, 서버 사이드 렌더링을 사용하는 것이 좋을까?

    먼저 서버 사이드 렌더링의 강점은 검색 엔진 최적화(SEO, Search Engine Optimization) 다.

    화면의 내용이 이미 다 그려진 상태로 클라이언트에 넘어오기 때문에 내용의 노출 정도가 높아 검색엔진에서

    높은 점수를 받을 수 있다. 반면에, 클라이언트 사이드 렌더링은 클라이언트가 웹 페이지를 받고 나서도 자바스크립트

    (또는 프레임워크)로 추가 내용을 화면에 부착하고 그려 줘야 하기 때문에 노출 정도가 상대적으로 낮다.

    

    서버 사이드 렌더링의 또 다른 강점은 초기 화면 렌더링 속도다. 다 그려져 있는 상태에서 화면에 단순히 나타내기만

    하는 것과 자바스크립트 라이브러리를 로딩하고 데이터와 화면 요소를 계산하여 화면에 나타내는 것은 속도에서 많은

    차이가 있다. 단순하게 생각하면 화면을 그리기 위한 자바스크립트 라이브러리를 몇 개 더 다운로드하는 시간부터 이미

    추가로 발생한다. 

    

    물론 클라이언트 사이드 렌더링이 주는 매끄러운 화면 전환과 사용자 경험의 향상은 큰 장점이다. 

    따라서 웹 앱의 성격에 따라 적재적소에 맞는 기법을 사용하는 것이 중요하다. 뷰 서버 사이드 렌더링을 더 알고 싶다면

    다음 링크를 참고하자.

    뷰 공식 사이트 서버 사이드 렌더링 : https://ssr.vuejs.org/en/

    서버 사이드 렌더링 라이브러리 Nuxt.js : https://nuxtjs.org/

## 6-2.뷰 개발을 위한 웹팩

* 웹팩(webpack)은 최신 프런트엔드 프레임워크인 앵귤러, 리액트, 뷰에서 모두 권하는 모듈 번들러다.

  뷰 CLI로 생성한 프로젝트에서 사용하는 웹팩 데브 서버와 웹팩 설정 파일(webpack.config.js)에 대해 살펴 보자.

### 6-2-1.웹팩이란?

* 웹팩은 흔히 모듈 번들라라고 알려져 있다. 공식 홈페이지에서도 다음처럼 모듈 번들러라고 부르고 있다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/84.png) 

  여기서부터 '모듈이 무엇이고, 번들러는 또 무엇인가?' 라는 의문을 가질 수 있을 것이다. 공식 홈페이지에서는

  웹팩을 '서로 연관이 있는 모듈 간의 관계를 해석하여 정적인 자원으로 변환해 주는 변환 도구'라고 정의한다.

  이를 좀 더 쉽게 풀어 설명하면 '파일 간의 연관 관계를 파악하여 하나의 자바스크립트 파일로 변화해 주는 변환도구' 다.

  

  물론 웹팩의 플러그인 기능을 활용하면 1개 이상의 자바스크립트 파일 또는 CSS, HTML 파일을 추가로 생성할 수는 있다.

  다만 기본적인 취지 자체는 '애플리케이션 동작과 관련된 여러 개의 파일(HTML, CSS, 자바스크립트, 이미지 등)' 들을

  1개의 자바스크립트 파일 안에 다 넣어 버리고, 해당 자바스크립트 파일만 로딩해도 웹 앱이 돌아가게 하자' 는 것이다.

  

  모든 파일의 내용을 1개의 파일에 담는 이유는 웹 앱의 로딩 속도를 향상 시키는 것과 연관이 있다. 일반적으로 웹 페이지를 

  브라우저에 나타내기 위해 웹 화면을 구성할 때 화면 구성에 필요한 자바스크립트, CSS, 이미지 파일마다 서버로 보내는 HTTP 요청이

  발생한다. 따라서 HTTP 네트워크 요청 숫자가 늘어나면 늘어날수록 웹 화면 로딩 시간은 길어질 수밖에 없다.

  

  예를 들어, HTTP 요청 1개에 2초가 소요된다고 하면 1개의 파일 요청과 30~40개의 파일 요청은 느린 인터넷 환경에서 최소 1분의 

  차이가 난다. 그러므로 당연히 HTTP 요청 숫자를 줄여야 웹 페이지 로딩이 빨라지고, 이는 결국 더 나은 사용자 경험을 제공하는 

  결과로 이어진다. 이런 문제를 개선하기 위해 예전부터 걸프(Gulp), 그런트(Grunt)와 같은 웹 자동화 도구들보다 존재 했으며,

  최근에는 이 도구들 보다 더 많은 기능을 추가로 제공하는 웹팩이 등장했다.

  ```js
  참고:걸프와 그런트에 대해 더 알고 싶다면 검색 엔진에 'gulp tutorial', 'grunt tutorial'을 검색해 보다.
  걸프는 https://scotch.io/tutorials/automate-your-tasks-easily-with-gulp-js 사이트를 추천한다.
  ```

  

### 6-2-2.웹팩의 주요 속성

* 웹팩을 사용할 때 알아둬야 하는 주요 속성은 크게 다음 5가지 이다.

  | 속성    | 설명                                                         |
  | ------- | ------------------------------------------------------------ |
  | entry   | 웹팩으로 빌드(변환)할 대상 파일을 지정하는 속성이다. <br/>entry로 지정한 파일의 내용에는 전체 애플리케이션 로직과 필요 라이브러리를 로딩하는 로직이 들어간다. |
  | output  | 웹팩으로 빌드한 결과물의 위치와 파일 이름 등 세부 옵션을 설정하는 속성이다. |
  | loader  | 웹팩으로 빌드할 때 HTML, CSS, PNG(이미지) 파일 등을 자바스크립트로 변환하기 위해 필요한 설정을 정의하는 속성이다. |
  | plugin  | 웹팩으로 빌드하고 나온 결과물에 대해 추가 기능을 제공하는 속성이다.<br />예를 들어, 결과물의 사이즈를 줄어거나 결과물(기본적으로 자바스크립트)을 기타 CSS, HTML 파일로 분리하는 기능 등이 있다. |
  | resolve | 웹팩으로 빌드할 때 해당 파일이 어떻게 해석되는지 정의하는 속성이다.<br />예를 들어, 특정 라이브러리를 로딩할 때 버전은 어떤 걸로 하고, 파일 경로는 어디로 지정하는지 등을 정의한다. |

### 6-2-3.웹팩 데브 서버

* 웹팩 데브 서버(webpack-dev-server)란 웹팩 설정 파일의 변화를 감지하여 빠르게 웹팩을 빌드할 수 있도록 지원하는

  유틸리티이자 노드제이에스(Node.js) 서버다. 웹팩 데브 서버는 웹팩 설정 파일의 내용이 변경되면 브라우저 화면을 

  자동으로 새로 고침하고, 바로 다시 웹팩으로 빌드하는 기능을 갖고 있다.

  ```js
  참고 : 서버구성은 노드제이에스 환경 위에 익스프레스(Express)라는 서버 프레임워크가 올라간 형태다.
  ```

  

  CLI로 webpack-simple 프로젝트를 생성하고, npm install 명령어로 필요한 라이브러리를 설치한 후 "npm run dev"

  명령어를 실행하면 아래와 같이 결과가 출력된다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/85.png) 

  첫 번째 줄은 웹팩 데브 서버가 노드로 로컬 서버 하나를 띄워 http://localhost:8080에 프로젝트를 실행하고 있다는 의미다.

  두 번째 줄은 /dist/에 있는 웹팩 결과물로 웹 앱을 로딩하고 있다는 의미다.

  

  그런데 사실 웹팩을 빌드하려면 "npm run build" 라는 명령어를 사용해야 한다. 이 명령어가 아닌 "npm run dev" 명령어를 

  사용했는데도 현재 애플리케이션은 마치 웹팩으로 빌드한 결과물을 정상적으로 실행하고 있는 것처럼 동작한다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/86.png) 

  왼쪽 그림을 보면 "npm run dev" 명령어로 프로젝트를 실행했을 때 프로젝트 구조에 /dist/라는 폴더는 존재하지 않는다.

  존재하지도 않는 폴더의 내용을 참고하고 있는 것이다. 결론적으로, "npm run build" 명령어로 /dist/라는 웹팩 빌드 결과물을

  만들지 않아도 "npm run dev" 명령어를 실행했을 때 마치 웹팩으로 빌드한 것 같은 효과를 얻게 된다는 것을 알 수 있다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/87.png) 

  

  그럼 "npm run dev" 명령어로 띄운 서버에서 참조하고 있는 빌드 결과물은 어디에 있을까? 바로 메모리 상에 있다.

  웹팩 데브 서버는 빌드한 파일을 파일 시스템에 저장하지 않고 컴퓨터 메모리에만 저장하기 때문에 파일 시스템(폴더) 

  상에서는 빌드 파일을 확인할 수 없다. 이렇게 하는 이유는 파일 시스템에 파일을 쓰고 읽는 시간보다 메모리에 저장하고 

  읽는 시간이 더 빠르기 때문이다. 그래서 웹팩 데브 서버를 인 메로리(in memory) 기반이라고 말한다.



### 6-2-4.webpack-simple 프로젝트의 웹팩 설정 파일 분석

* 뷰 CLI로 webpack-simple 프로젝트를 생성하고 나면 프로젝트 최상위 레벨에서 webpack.config.js 라는 웹팩 

  설정 파일을 확인할 수 있다. 뷰 애플리케이션을 실행하기 위해 npm run dev 명령어를 입력했을 때 webpack.config.js 파일에

  정의된 설정에 따라 .vue 파일을 포함한 기타 파일들이 웹팩으로 빌드가 된다. 그럼 webpack.config.js 파일을 살펴보자.

  

  * ##### 파일 경로와 웹팩 라이브러리 로딩

    ```js
    var path = require('path')
    var webpack = require('webpack')
    ```

    output 속성에서 사용할 노드 path 라이브러리와 웹팩 플러그인에서 사용할 node_modules의 

    웹팩 라이브러리를 node_modules 폴더에서 로딩하여 path, webpack에 각각 저장한다.

    

  * ##### entry 속성

    ```js
    entry : './src/main.js',
    ```

    웹팩으로 빌드할 파일을 src 폴더 밑의 main.js 파일로 지정한다. main.js 파일에 정의한 내용에

    따라 애플리케이션의 구성 요소 및 파일들이 웹팩으로 번들링(빌드)된다.

    

  * ##### output 속성

    ```js
    output : {
        path : path.resolve(__dirname, './dist'),
        publicPath : '/dist/',
        filename : 'build.js'
    }
    ```

    웹팩으로 빌드를 하고 난 결과물 파일의 위치와 이름을 지정한다.

    결과물 파일을 위치는 dist/build.js 다.

    

  * ##### module 속성

    웹팩으로 애플리케이션 파일들을 빌드(변환)할 때 HTML, CSS, PNG(이미지) 등의 파일을 

    자바스크립트로 변환해 주는 로더를 지정한다.

    ![](C:/bro-lab/01.vue/vue/markdown/img/88.png) ![](C:/bro-lab/01.vue/vue/markdown/img/89.png)  

    1. 프로젝트 폴더 안의 css 파일에 vue-style-loader와 css-loader를 적용한다.

       css-loader를 적용하여 css 파일을 모두 자바스크립트로 변환한다. 그리고 앞에서 변환된 css 속성들이

       최종적으로 vue-style-loader을 거쳐 index.html에 &lt;style> 태그로 삽인된다.

    2. vue 파일에는 vue-loader를 적용한다. vue 파일의 &lt;template>, &lt;script>, &lt;style> 등의 내용이 

       자바스크립트로 변환되어 웹팩 빌드 결과물에 포함된다.

    3. 자바스크립트 파일에 babel-loader를 적용한다. 자바스크립트 파일의 ES6 문법을 모든 브라우저에서 

       호환 가능한 자바스크립트로 변환(transpile)한다.

    4. 이미지 파일들은 file-loader를 이용하여 자바스크립트 파일로 변환한다.

       

  * ##### resolve 속성

    ```js
    resolve : {
        alias : {
            'vue$' : 'vue/dist/vue.esm.js'
        },
        extensions : ['*', '.js', '.vue', '.json']
    },
    ```

    웹팩으로 빌드할 때 뷰 라이브러리의 여러 유형 중 어떤 걸 선택할지 지정한다.

    여기서 설정된 vue.esm.js는 최신 웹팩 버전과 사용할 수 있는 Full 버전의 라이브러리를 의미하며, 

    이렇게 별도로 설정하지 않으면 런타임 버전인 vue.runtime.esm.js를 사용한다.

    

  * ##### devServer속성

    ```js
    devServer : {
        historyApiFallback : true,
        noInfo  : true,
        overlay : true
    }
    ```

    웹팩 데브 서버 관련 속성을 지정한다.

    historyApiFallback 속성은 클라이언트 사이드 라우팅인 뷰 라우터와 함께 사용하기 위해 true로 지정한다.

    noInfo 속성은 처음 서버를 시작할 때만 웹팩 빌드 정보를 보여주고, 이후 변경 시에는 빌드 정보를 보여주지 않는다.

    overlay 속성은 웹팩으로 빌드할 때 오류가 있으면 브라우저 화면 전체에 오류를 표시한다.

    

  * ##### performance 속성

    ```js
    performance : {
        hints : false
    },
    ```

    웹팩으로 빌드한 파일의 크기가 250kb를 넘으면 경고 메시지를 표시할지를 설정한다.

    hints 가 false 이므로 크기와 관계 없이 경고가 표시되지 않는다.

    

  * ##### devtool 속성

    ```js
    devtool : '#eval-source-map'
    ```

    웹팩으로 빌드된 파일로 웹 앱을 구동했을 때 개발자 도구에서 사용할 디버깅 방식을 지정한다.

    옵션이 여러 가지이므로 자세한 내용은 https://webpack.js.org/configuration/devtool/를 참고하자.

    

  * ##### 배포할 때 옵션

    배포할 때 애플리케이션의 성능 향상을 위해 추가한 설정이다.

    ![](C:/bro-lab/01.vue/vue/markdown/img/90.png) 

    1. 개발자 도구 분석 옵션을 #source-map으로 지정한다.

    2. 자바스크립트 파일의 크기를 줄이는 Uglify 플러그인과 환경 변수 값을 설정한다.

    

    앞에서 다룬 속성들 중 entry, output, loader, plugin, resolve 속성은 중요하므로 꼭 기억해 

    두는 것이 좋다. 

    

    아래는 프로젝트 폴더를 기준으로 빌드 과정을 도식화한 그림이다.

    ![](C:/bro-lab/01.vue/vue/markdown/img/91.png) 

    앞의 프로젝트는 main.js 파일에서 App.vue 파일과 Vue.js 라이브러리를 불러와서 애플리케이션을 

    동작시키고, 또 App.vue에서 logo.png 파일을 이용하여 웹 페이지를 구성하는 구조다.

    따라서 웹팩으로 빌드할 때 파일 간의 관계에 따라 build.js 파일을 생성한다. 생성된 build.js는

    애플리케이션 구조대로 파일(모듈) 간의 순서가 알맞게 설정되어 있다. 결론적으로, index.html 파일에서

    웹팩으로 빌드한 build.js 파일만 로딩하면 애플리케이션 로직을 구성하는 vue 파일, png 파일, 자바스크립트

    라이브러리를 로딩한 것과 동일한 방식으로 동작한다.

  

## 6-3.뷰 개발을 위한 ES6

### 6-3-1.ES6란?

* ES6(ECMAScript 2015)는 최신 자바스크립트 문법이자 스펙이다.

  ECMA에서 자바스크립트의 첫 표준을 제정한 이래 2015년에 문법적으로 가장 큰 변화가 있었다.

  이렇게 변경된 자바스크립트를 ECMAScript 2015 또는 ES6라고 부르고, 기존 자바스크립트를 ES5라고 부른다.

  ES6는 개발자가 더 쉽게 코드를 작성할 수 있도록 문법을 단순화하고, 미숙한 코딩으로 인한 오류를 미연에

  방지하기 위해 언어 자체에서 유효 범위를 제한하는 등의 기능을 추가했다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/92.png) 

  

  위 코드는 둘 다 변수를 선언하고 2개의 숫자를 더하는 함수를 선언해서 10, 20을 더한 것을 출력하는 코드 이다.

  변수를 선언하는 const, let와 함수를 정의하는 화살표 함수 방식 이외에도 많은 부분의 문법이 바꼈다.

  여기서는 뷰로 개발할 때 알면 도움이 되는 몇 가지 주요 문법만 살펴보겠다.


### 6-3-2.const와 let 예약어

* const와 let은 변수를 선언할 때 사용하는 예약어 다. 

  ES5 에서는 변수를 선언할 때 var를 사용하지만 ES6는 var 대신 let으로 변수를 선언한다. 그리고 선언한 후 값이 

  바뀌지 않고 동일하게 사용되는 변수에 대해서는 const를 추가로 사용할 수 있다. 이렇게 구분하는 이유는 변수를 

  선언할 때 변수의 용도를 미리 고민하고 변수의 성격에 따라 변수 선언 방식을 구분함으로써 코드의 가독성을 높이기 위해서다.

  

  다음의 코드를 통해 const와 let의 특징을 구분할 수 있다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/93.png) 

  

  let은 정상적으로 a의 값이 20으로 다시 할당되지만 const는 값을 다시 할당하려고 하면 오류가 발생한다.

  const 예약어로 선언한 변수에 한 번 할당된 값은 다시 변경할 수 없기 때문이다. 따라서 상수 값과 함수를 

  정의할 때는 const를 활용하고, 반복문을 비롯한 나머지 변수를 선언할 때는 let을 활용하는게 좋다.

  

### 6-3-3.블록의 유효 범위

* 두 번째로 살펴볼 특징은 블록의 유효 범위(block scope) 다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/94.png) 

  

  ES5로 작성한 코드를 크롬 개발자 도구의 Console 패널에서 실행하면 0,1,2,3,4,5 가 출력된다.

  ES5 문법의 기본적인 특징 중 하나가 '변수의 유효 범위가 블록 단위로 제한되지 않는다' 라는 점이다.

  따라서 var i = 10; 으로 변수 i값을 선언한 상태에서 for문의 초기 값에 var i=0 을 선언하면 for문 밖에서

  선언했던 변수 i의 값을 다시 선언하는 것과 같은 효과가 나타난다. 따라서 for문이 끝나고 난 후 {} 밖에서

  console.log(i); 를 실행하면 for문의 최종 실행 결과가 출력된다.

  

  반대로 ES6의 출력 결과는 for문 실행이 끝난 후에도 for문을 실행하기 전의 값인 10이 동일하게 출력된다.

  for문에서 초기 값을 let으로 선언했기 때문에 let i = 0; 의 유효 범위가 for문 내부로 제한된 것이다.

  이처럼 ES6의 let으로 변수를 선언하면 {} 안으로 변수의 유효 범위가 한정된다.

  

### 6-3-4.화살표 함수

* 화살표 함수(Arrow Functions)는 기존 ES5의 함수 정의 방식을 간소화한 문법이다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/95.png) 

  

  위 코드는 앞에서 보았듯이 인자 값 2개를 합산하는 함수 표현식이다.

  sumNumbers(10, 20)를 실행하면 두 코드의 결과 값이 30으로 똑같다. 이렇게 함수를 선언할 때 function()으로

  길게 선언할 필요 없이 => 로 간단하게 선언할 수 있다. 이와 같은 방식으로 코드를 구성하면 구현 속도도 빨라지고

  코드의 전체 길이도 짧아진다.

  

### 6-3-5.Import와 Export

* import와 export는 자바스크립트 모듈화와 관련된 기능이다.

  모듈화란 코드를 특정 기능이나 로직 단위로 구분하여 각각의 모듈로 관리하는 것을 말한다.

  각 모듈은 다른 모듈에 영향을 주지 않고 독립적으로 실행할 수 있어야 한다. 자바스크립트는 원래의 언어 자체에 이런

  모듈화 기능이 없기 때문에 라이브러리나 프로그래밍 패턴 등으로 모듈화를 지원해 왔다. 

  예를 들아, CommonJs, RequireJs 등 모듈화를 지원하는 라이브러리를 이용해 원하는 시점에 특정 자바스크립트 파일을

  로딩하거나 독립적인 실행 영역을 보장받을 수 있다. 또는 다음과 같은 프로그래밍 패턴으로 변수가 서로 충돌하는 것을 

  방지할 수 있다.

  ```html
  참고 : 모듈화 지원 라이브러리가 궁금하다면 'requirejs amd'와 'common js'를 검색해 보자.
  ```

  ![](C:/bro-lab/01.vue/vue/markdown/img/96.png) 

  위 코드는 모듈화 기법 중 네임스페이스(name space)를 활용하여 num 변수의 범위가 충돌하지 않게 모듈화 하는 코드다.

  이렇게 되면 num 값이 10과 20으로 각각의 네임스페이스에 보존된다. 여러 개의 자바스크립트 파일을 사용할 때 변수가

  서로 충돌하지 않게 하기 위해 사용하는 일반적인 프로그래밍 기법이다.

  

  하지만 매번 이렇게 변수의 유효 범위를 구분해 주기 위해 모듈화 패턴을 사용하는 건 번거롭다.

  이러한 수고를 덜어 주고자 ES6는 언어 자체에서 import와 export로 모듈화를 지원한다.

  ```html
  자바스크립트에 모듈화가 필요한 이유
  자바스크립트는 변수의 유효 범위가 파일 단위로 구분되지 않는다. 기본적으로 같은 유효 범위는 갖는다.
  그래서 복잡한 애플리케이션을 작성하다 보면 기존에 정의된 변수를 실수로 재정의하거나 유효 범위가 충돌하는
  경우가 발생한다. 따라서 이런 문제를 방지하기 위해 모듈화가 필요하다.
  ```

  import란 한 파일에서 다른 파일의 내용을 불러올 때 사용한다. 

  export는 한 파일의 특정 기능을 다른 파일에서 사용할 수 있도록 설정할 때 사용한다. 

  ![](C:/bro-lab/01.vue/vue/markdown/img/97.png) 

  

  위 코드는 main.js 파일에서 app/login.js 파일의 id 값을 불러와 콘솔로 출력하는 예제다.

  main.js 파일을 실행하는 시점에 login.js 파일에 선언된 일부 내용(변수id)을 불러와 main.js 파일

  의 로직에서 사용했다. 이 동작을 그림으로 나타내면 아래와 같다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/98.png) 

  

  * ##### 뷰 싱글 파일 컴포넌트 체계에서 import와 export 살펴보기

    앞의 내용을 바탕으로 뷰 싱글 파일 컴포넌트 체계를 다시 살펴보자.

    webpack-simple 프로젝트에서 아래와 같은 뷰 파일이 2개 있다고 가정하자

    ![](C:/bro-lab/01.vue/vue/markdown/img/99.png)  

    ![](C:/bro-lab/01.vue/vue/markdown/img/100.png) 

    앞의 App.vue 파일에 컴포넌트로 등록된 Login 컴포넌트는 Login.vue 파일 내용과 동일하다.

    왜냐하면 import로 Login.vue 파일의 내용을 가져와서 Login 이라는 객체에 담고, Login 객체를

    components 속성에서 컴포넌트로 등록했기 때문이다. 

    참고로, import 대상 파일에 export가 정의되어 있지 않으면 기본적으로 파일의 모든 내용이 export 된다.

    

    여기서 Login.vue 파일의 내용을 보면 &lt;h1>을 포함하는 간단한 &lt;template>만 있다.

    따라서 npm run dev 명령어로 애플리케이션을 실행했을 때 App.vue 파일에 Login.vue 파일의 내용이

    포함되어 화면에 표시된다.

    ![](C:/bro-lab/01.vue/vue/markdown/img/101.png) 

    

    


## 6-4.뷰 CLI에서 사용하는 NPM

### 6-4-1.NPM 소개

* 지금까지는 뷰 CLI로 프로젝트를 구성하고 실행할 때 npm install, npm run dev와 같은 명령어를 사용했다.

  NPM(Node Package Manager)의 정의에 대해서는 이미 살펴본 바 있다. 

  즉, '전 세계 자바스크립트 라이브러리가 존재하는 공개 저장소' 라고 설명했는데, 자바스크립트의 활용 범위가 

  넓어지면서 자바스크립트 라이브러리를 쉽게 다운로드할 수 있는 NPM은 현대 웹 앱에서는 없어서는 안 될 도구다. 

  따라서 이러한 패키지 관리 도구 1개 정도는 자유자재로 다룰 줄 알아야 복잡한 뷰 프로젝트도 쉽게 구성할 수 있다.

  

  이번 절에서는 뷰 CLI를 사용할 때 알고 있으면 좋을 만한 NPM 기능을 살펴 보겠다.

  * NPM 설치 명령어
  * 전역설치 vs 지역설치
  * NPM 커스텀 명령어

### 6-4-2.NPM 설치 명령어

* NPM에서 가장 흔하게 사용되는 명령어는 npm install 이라는 설치 명령어다.

  npm install 명령어를 명령 프롬프트 창에 입력하면 npm 설정 파일(package.json)에 설정된 라이브러리 목록을

  다운로드할 수 있다. 앞에서 뷰 CLI로 webpack-simple 프로젝트를 생성할 때 사용했다. 여기서 웹팩 추가

  설정을 위해 플러그인 라이브러리나 애플리케이션 로직과 관련된 외부 라이브러리를 추가하려면 어떻게 해야 할까?

  --save 옵션과 --save-dev 옵션을 활용하면 된다.

  

  * ##### npm install --save 옵션과 --save-dev 옵션

    --save 옵션과 --save-dev 옵션은 모두 해당 라이브러리를 프로젝트 폴더에 다운로드하는 옵션이다.

    두 옵션의 차이점은 단지 npm 설정 파일의 라이브러리 목록에 설치된 라이브러리 이름이 추가되는 곳만 

    다르다는 것이다. 다음 코드를 보자.

    ![](C:/bro-lab/01.vue/vue/markdown/img/102.png) 

    뷰 CLI로 생성한 webpack-simple 프로젝트의 package.json 파일 일부다. dependencies 속성에는

    뷰 코어 라이브러리가 추가되어 있고, devDependencies 속성에는 웹팩과 관련된 라이브러리가 추가되어 있다.

    이미 짐작했을지 모르겠지만 dependencies 속성에는 애플리케이션을 동작시키는 데 필요한 라이브러리가 들어가고,

    devDependencies 속성에는 애플리케이션을 개발할 때 필요한 라이브러리가 들어간다.

    

    라이브러리를 설치할 때 npm install --save 명령어를 사용하면 dependencies 속성에 라이브러리 이름이 추가되고,

    npm install --save-dev 명령어를 사용하면 devDependencies 속성에 라이브러리가 추가된다.

    ![](C:/bro-lab/01.vue/vue/markdown/img/103.png) ![](C:/bro-lab/01.vue/vue/markdown/img/104.png) 

    앞쪽의 화면과 위 코드는 npm install --save 명령어로 로대시(lodash)라는 자바스크립트 라이브러리를

    설치한 결과다. dependencies 속성에 lodash 라이브러리가 버전과 함께 추가됐다.

    

    이번에는 반대로 npm install lodash --save-dev 명령어를 입력해 보자

    ![](C:/bro-lab/01.vue/vue/markdown/img/105.png) 

    기본적으로 npm install 명령어를 입력하면 모든 라이브러리를 설치할 수 있지만 이러한 차이점이 있다는 것을 알아 두자



### 6-4-3.전역 설치와 지역 설치

* -global 옵션은 해당 라이브러리를 시스템 레벨에 설치하는 옵션이다. 

  방금 전에 살펴본 --save와 --save-dev 옵션은 해당 프로젝트에 라이브러리 파일을 다운로드 한다.

  만약 옵션 없이 npm install 명령어만 입력해도 동일하게 해당 프로젝트에 라이브러리 파일을 다운로드 할 수 있다.

  이처럼 -global 옵션을 이용해 시스템 레벨에 설치하는 것을 전역 설치 --save, --save-dev 같이 해당 프로젝트에 

  설치하는 것을 지역 설치라고 한다.

  

  아래 그림은 새 폴더를 하나 생성한 후 앞에서 사용했던 webpack-simple 프로젝트의 package.json 파일을 복사해온 폴더 구조다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/106.png) 

  위 폴더 위치에서 명령 프롬프트 창을 열고 npm install webpack-g 명령어를 입력한다.

  ```html
  -g는 -global 옵션의 약어다. install 명령어 역시 i로 줄일 수 있다. 
  ex) npm i webpack -g
  ```

  ![](C:/bro-lab/01.vue/vue/markdown/img/107.png) 

  설치는 제대로 되었는데 새로 생성한 현재 폴더에는 아무것도 추가되지 않았다.

  왜냐하면 라이브러리를 현재 폴더 위차가 아닌 전역(시스템 레벨)에 설치 했기 때문이다.

  

  그럼 이번에는 다음과 같이 npm install webpack 명령어를 입력한다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/108.png) 

  라이브러리를 설치했다는 메시지와 함께 폴더 구조를 살펴보면 다음과 같이 node_modules 폴더가 추가된 것을

  확인할 수 있다. node_modules 폴더를 열어보면 아래에 웹팩과 관련된 라이브러리 파일들이 설치되어 있다.

  ![](C:/bro-lab/01.vue/vue/markdown/img/109.png) 

  

### 6-4-4.NPM 커스텀 명령어

* 뷰 CLI로 구성한 프로젝트를 실행할 때 npm run build와 npm run dev 명령어를 사용했다.

  npm run build 명령어는 웹팩으로 프로젝트를 빌드할 때 사용했고, 

  npm run dev 명령어는 프로젝트를 웹팩 데브 서버로 구동할 때 사용했다.

  이 명령어들은 어디에서 나온건지 아래 코드를 살펴 보자.

  ![](C:/bro-lab/01.vue/vue/markdown/img/110.png) 

  위 코드는 npm 설정 파일(package.json)의 scripts 속성 코드다. dev 속성과 build 속성을 보면 

  여러가지 옵션 값이 들어가 있는 걸 알 수 있다. 

  dev 속성은 웹팩 데브 서버를 실행하는 명령어와 함께 --open과 같은 추가 옵션들을 줬고, 

  build 속성은 웹팩 빌드를 실행하는 명령어와 함께 --progress와 같은 추가 옵션들을 줬다.

  이 dev 속성과 build 속성이 npm run으로 명령어를 실행할 때의 대상 속성이다. 따라서 명령 프롬프트 창에

  npm run dev 명령어를 입력하면 webpack-dev-server --open --hot 명령어를 입력한 것과 같은 효과를 얻을 수 있다.

  

  이와 같은 방식으로 npm 설정 파일의 scripts 속성에 원하는 명령어를 추가하고, 해당 명령어를 실행했을 때 

  동작하는 옵션들을 정의할 수 있다. 이렇게 매번 긴 명령어를 입력하지 않고 'npm run 명령어' 형식으로 간다한게 

  입력해서 실행할 수 있다. 프로젝트가 커지고 웹팩 설정 파일이 복잡해 지면 scripts 속성 안에 명령어를 추가해서 사용해 보자.














































































​	   
